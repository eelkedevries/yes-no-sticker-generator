<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YES/NO Sticker Generator</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 24px; color: #111; }
    .wrap { max-width: 1040px; }

    .intro {
      margin: 0 0 14px 0;
      line-height: 1.45;
      font-size: 15px;
      color: #222;
    }
    .intro a { color: #0b65c2; text-decoration: none; }
    .intro a:hover { text-decoration: underline; }

    h2 { margin-bottom: 10px; }

    .row { display: flex; gap: 12px; flex-wrap: wrap; margin: 12px 0; align-items: end; }
    .col { flex: 1 1 420px; }

    .section-title {
      margin-top: 14px;
      font-size: 15px;
      font-weight: 700;
      color: #111;
    }
    .section-subtitle {
      margin-top: 2px;
      font-size: 14px;
      color: #333;
    }

    label { display: block; font-size: 14px; margin-bottom: 6px; }
    input[type="text"]{
      width: 100%; padding: 10px 12px; font-size: 16px;
      border: 1px solid #ccc; border-radius: 8px; background: #fff;
    }

    .radio-group {
      margin-top: 8px;
      display: grid;
      gap: 8px;
    }
    .radio-item {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      background: #fff;
    }
    .radio-item input[type="radio"] {
      margin-top: 3px;
      transform: scale(1.05);
    }
    .radio-label {
      display: grid;
      gap: 2px;
    }
    .radio-name {
      font-weight: 700;
      font-size: 14px;
      color: #111;
    }
    .radio-pair {
      font-size: 13px;
      color: #333;
      line-height: 1.35;
    }

    button {
      padding: 10px 14px; font-size: 16px; cursor: pointer;
      border: 1px solid #ccc; border-radius: 8px; background: #fff;
    }
    button:active { transform: translateY(1px); }

    canvas { width: 100%; border: 1px solid #ddd; border-radius: 12px; display: block; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>YES/NO Sticker Generator</h2>

    <p class="intro">
      This YES/NO image generator helps researchers respond quickly and clearly to unwanted review requests, including automated mass invitations, predatory journals, and high-fee for-profit publishers that rely on unpaid reviewing and often place accepted papers behind paywalls.
      <br><br>
      Made by Eelke de Vries:
      <a href="https://www.linkedin.com/in/eelkedevries" target="_blank" rel="noopener noreferrer">https://www.linkedin.com/in/eelkedevries</a>,
      <a href="https://github.com/eelkedevries" target="_blank" rel="noopener noreferrer">https://github.com/eelkedevries</a>.
    </p>

    <div class="section-title">Select the kind of review invitation you received.</div>

    <div class="radio-group" role="radiogroup" aria-label="Select the kind of review invitation you received">
      <div class="radio-item">
        <input type="radio" id="preset_forprofit" name="preset" value="forprofit" />
        <div class="radio-label">
          <div class="radio-name">For-profit publishers</div>
          <div class="radio-pair">
            <strong>NO:</strong> Peer review for paywalls and APCs<br>
            <strong>YES:</strong> Peer review for diamond open access
          </div>
        </div>
      </div>

      <div class="radio-item">
        <input type="radio" id="preset_predatory" name="preset" value="predatory" />
        <div class="radio-label">
          <div class="radio-name">Predatory publishers</div>
          <div class="radio-pair">
            <strong>NO:</strong> Predatory publishing practices<br>
            <strong>YES:</strong> Legitimate academic journals
          </div>
        </div>
      </div>

      <div class="radio-item">
        <input type="radio" id="preset_automated" name="preset" value="automated" />
        <div class="radio-label">
          <div class="radio-name">Automated review invitations</div>
          <div class="radio-pair">
            <strong>NO:</strong> Automated review invitations<br>
            <strong>YES:</strong> Legitimate editorial requests
          </div>
        </div>
      </div>
    </div>

    <div class="section-title">Or enter your personal message</div>

    <div class="row">
      <div class="col">
        <label for="noText">NO text (left)</label>
        <input id="noText" type="text" value="Peer review for paywalls and APCs" />
      </div>
      <div class="col">
        <label for="yesText">YES text (right)</label>
        <input id="yesText" type="text" value="Peer review for diamond open access" />
      </div>
    </div>

    <div class="row">
      <button id="downloadBtn">Download PNG</button>
      <button id="copyBtn">Copy image</button>
      <button id="copyLinkBtn">Copy link</button>
      <button id="clearAllBtn">Clear all</button>
    </div>

    <canvas id="c" width="1800" height="360"></canvas>
  </div>

  <script>
    // ---------- DOM ----------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const noInput = document.getElementById("noText");
    const yesInput = document.getElementById("yesText");

    const presetRadios = Array.from(document.querySelectorAll('input[name="preset"]'));

    const downloadBtn = document.getElementById("downloadBtn");
    const copyBtn = document.getElementById("copyBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    // Fixed output size
    const FIXED_W = 1800;
    const FIXED_H = 360;

    // ---------- Defaults ----------
    const DEFAULTS = {
      yes: "Peer review for diamond open access",
      no: "Peer review for paywalls and APCs"
    };

    const PRESETS = {
      forprofit: {
        no: "Peer review for paywalls and APCs",
        yes: "Peer review for diamond open access"
      },
      predatory: {
        no: "Predatory publishing practices",
        yes: "Legitimate academic journals"
      },
      automated: {
        no: "Automated review invitations",
        yes: "Legitimate editorial requests"
      }
    };

    const COLORS = {
      bg: "#000000",
      border: "#FFFFFF",
      no: "#E53935",
      yes: "#00B050",
      text: "#FFFFFF"
    };

    // ---------- URL params (yes/no only) ----------
    // Supported:
    // ?yes=...&no=...
    function getParams() {
      const p = new URLSearchParams(window.location.search);
      return { yes: p.get("yes"), no: p.get("no") };
    }

    function applyParams() {
      const p = getParams();
      if (p.yes !== null) yesInput.value = p.yes;
      if (p.no !== null) noInput.value = p.no;
    }

    function updateURL() {
      const p = new URLSearchParams();
      p.set("yes", yesInput.value);
      p.set("no", noInput.value);
      const newUrl = `${window.location.pathname}?${p.toString()}`;
      window.history.replaceState({}, "", newUrl);
    }

    async function copyLink() {
      try {
        await navigator.clipboard.writeText(window.location.href);
        alert("Link copied to clipboard.");
      } catch (e) {
        alert("Could not copy link. You can copy it manually from the address bar.");
      }
    }

    // ---------- Text helpers ----------
    function wrapText(targetCtx, text, maxWidth, fontSize, maxLines) {
      targetCtx.font = `bold ${fontSize}px Arial`;
      const words = (text || "").trim().split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";

      for (const w of words) {
        const test = line ? `${line} ${w}` : w;
        if (targetCtx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
      return lines.slice(0, maxLines);
    }

    // Fit a single shared font size for both "YES" and "NO" within the label blocks
    function fitLabelFontSize(targetCtx, labelBlockW, innerH) {
      const maxW = labelBlockW * 0.86;
      const maxH = innerH * 0.80;
      let size = Math.floor(innerH * 0.62);

      while (size > 20) {
        targetCtx.font = `bold ${size}px Arial`;
        const yesW = targetCtx.measureText("YES").width;
        const noW  = targetCtx.measureText("NO").width;

        if (yesW <= maxW && noW <= maxW && size <= maxH) return size;
        size -= 2;
      }
      return 20;
    }

    // ---------- Drawing ----------
    function drawSticker(targetCtx, W, H) {
      const border = Math.max(10, Math.round(W * 0.006));
      const pad = Math.round(W * 0.015);
      const sepW = Math.max(10, Math.round(W * 0.006));

      // Equal-sized red/green blocks
      const labelBlockW = Math.round(W * 0.16);
      const innerH = H - 2 * border;

      const totalInnerW = W - 2 * border;
      const textAreaW = (totalInnerW - 2 * labelBlockW - sepW) / 2;

      const xNoBlock = border;
      const xNoText = border + labelBlockW;
      const xSep = xNoText + textAreaW;
      const xYesText = xSep + sepW;
      const xYesBlock = xYesText + textAreaW;

      // Background
      targetCtx.clearRect(0, 0, W, H);
      targetCtx.fillStyle = COLORS.bg;
      targetCtx.fillRect(0, 0, W, H);

      // Outer border
      targetCtx.strokeStyle = COLORS.border;
      targetCtx.lineWidth = border;
      targetCtx.strokeRect(border / 2, border / 2, W - border, H - border);

      // Separator line
      targetCtx.fillStyle = COLORS.border;
      targetCtx.fillRect(xSep, border, sepW, innerH);

      // Blocks (equal widths)
      targetCtx.fillStyle = COLORS.no;
      targetCtx.fillRect(xNoBlock, border, labelBlockW, innerH);

      targetCtx.fillStyle = COLORS.yes;
      targetCtx.fillRect(xYesBlock, border, labelBlockW, innerH);

      // Big fixed labels
      targetCtx.fillStyle = COLORS.text;
      targetCtx.textAlign = "center";
      targetCtx.textBaseline = "middle";

      const labelFontSize = fitLabelFontSize(targetCtx, labelBlockW, innerH);
      targetCtx.font = `bold ${labelFontSize}px Arial`;
      targetCtx.fillText("NO", xNoBlock + labelBlockW / 2, H / 2);
      targetCtx.fillText("YES", xYesBlock + labelBlockW / 2, H / 2);

      // Text areas
      targetCtx.fillStyle = COLORS.text;
      targetCtx.textAlign = "left";
      targetCtx.textBaseline = "top";

      const startSize = Math.round(H * 0.18);
      const minSize = Math.max(18, Math.round(H * 0.10));
      const maxLines = 3;
      const maxW = textAreaW - 2 * pad;

      function fitTextLocal(text) {
        let size = startSize;
        while (size >= minSize) {
          targetCtx.font = `bold ${size}px Arial`;
          const lines = wrapText(targetCtx, text, maxW, size, maxLines);

          let ok = true;
          for (const ln of lines) {
            if (targetCtx.measureText(ln).width > maxW) { ok = false; break; }
          }
          if (ok) return { size, lines };
          size -= 2;
        }
        return { size: minSize, lines: wrapText(targetCtx, text, maxW, minSize, maxLines) };
      }

      const noFit = fitTextLocal(noInput.value);
      targetCtx.font = `bold ${noFit.size}px Arial`;
      let y = border + Math.round(H * 0.18);
      for (const line of noFit.lines) {
        targetCtx.fillText(line, xNoText + pad, y);
        y += noFit.size + Math.round(H * 0.04);
      }

      const yesFit = fitTextLocal(yesInput.value);
      targetCtx.font = `bold ${yesFit.size}px Arial`;
      y = border + Math.round(H * 0.18);
      for (const line of yesFit.lines) {
        targetCtx.fillText(line, xYesText + pad, y);
        y += yesFit.size + Math.round(H * 0.04);
      }
    }

    function renderPreview() {
      canvas.width = FIXED_W;
      canvas.height = FIXED_H;
      drawSticker(ctx, canvas.width, canvas.height);
    }

    // ---------- Export / clipboard ----------
    function downloadPNG() {
      const a = document.createElement("a");
      a.download = "yes-no-sticker.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    }

    async function copyImage() {
      try {
        if (!navigator.clipboard || !window.ClipboardItem) {
          alert("Clipboard image copy is not supported in this browser.");
          return;
        }
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
        if (!blob) {
          alert("Could not create image blob.");
          return;
        }
        await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
        alert("Image copied to clipboard.");
      } catch (e) {
        console.error(e);
        alert("Copy failed.");
      }
    }

    // ---------- Preset selection ----------
    function clearPresetSelection() {
      presetRadios.forEach(r => r.checked = false);
    }

    function applyPresetKey(key) {
      if (!key || !PRESETS[key]) return;
      noInput.value = PRESETS[key].no;
      yesInput.value = PRESETS[key].yes;
    }

    // ---------- Clear all ----------
    function clearAll() {
      clearPresetSelection();
      yesInput.value = DEFAULTS.yes;
      noInput.value = DEFAULTS.no;
      updateURL();
      renderPreview();
    }

    // ---------- Live updates ----------
    function onAnyChange() {
      updateURL();
      renderPreview();
    }

    // ---------- Init ----------
    applyParams();
    updateURL();
    renderPreview();

    // ---------- Events ----------
    yesInput.addEventListener("input", () => {
      // if user types, treat as personal message; do not force-clear preset selection
      onAnyChange();
    });
    noInput.addEventListener("input", () => {
      onAnyChange();
    });

    presetRadios.forEach(radio => {
      radio.addEventListener("change", () => {
        applyPresetKey(radio.value);
        onAnyChange();
      });
    });

    downloadBtn.addEventListener("click", downloadPNG);
    copyBtn.addEventListener("click", copyImage);
    copyLinkBtn.addEventListener("click", copyLink);
    clearAllBtn.addEventListener("click", clearAll);

    window.addEventListener("resize", () => renderPreview());
  </script>
</body>
</html>
