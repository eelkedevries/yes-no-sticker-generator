<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>My review policy</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 24px; color: #111; background: #fff; }
    .wrap { max-width: 1080px; }

.intro-panel { padding: 16px 16px 10px 16px; }
.intro-heading { font-size: 28px; margin: 0 0 10px 0; }
.section-heading { font-size: 20px; margin: 0 0 12px 0; }

    h1 { font-size: 28px; margin: 0 0 10px 0; }
    h2 { font-size: 20px; margin: 20px 0 10px 0; }
    .subtext {
      margin: 0 0 14px 0;
      line-height: 1.45;
      font-size: 14px;
      color: #222;
      max-width: 1000px;
    }

    .iconbar { display: inline-flex; gap: 10px; vertical-align: middle; margin-left: 6px; }
    .iconlink { display: inline-flex; align-items: center; justify-content: center; width: 22px; height: 22px; }
    .iconlink svg { width: 20px; height: 20px; display: block; }

    .panel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px 14px 6px 14px;
      background: #f7f8fa;
      margin: 10px 0 16px 0;
    }
    .panel-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 10px 0;
      color: #111;
    }

    .subsection {
      margin-top: 18px;
      padding-top: 14px;
      border-top: none;
    }
    .subsection:first-of-type {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }
    .subheading {
      font-size: 18px;
      font-weight: 700;
      margin: 0 0 10px 0;
      color: #111;
    }



    .section-box{
      border: 1px solid #d7dee9;
      border-radius: 12px;
      padding: 12px 12px;
      background: #f7f8fa;
      margin: 0;
    }
    .section-box--hf{ background: #f7f8fa; }
    .section-box--sizes{ background: #f7f8fa; }
.row { display: flex; gap: 12px; flex-wrap: wrap; margin: 12px 0; align-items: flex-start; }
    .col { flex: 1 1 420px; }

    label { display: block; font-size: 14px; margin-bottom: 6px; }
    input[type="text"], textarea {
      width: 100%;
      padding: 10px 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      box-sizing: border-box;
    }
    textarea { resize: vertical; min-height: 90px; }

    .radio-group { display: grid; gap: 8px; margin-top: 8px; }
    @media (min-width: 900px) {
      .radio-group { grid-template-columns: 1fr 1fr; }
    }

    .radio-item {
      display: flex; gap: 10px; align-items: flex-start;
      padding: 10px 12px; border: 1px solid #ddd; border-radius: 10px; background: #fff;
    }
    .radio-item input[type="radio"] { margin-top: 3px; transform: scale(1.05); }
    .radio-label { display: grid; gap: 2px; }
    .radio-name { font-weight: 700; font-size: 14px; color: #111; }
    .radio-pair { font-size: 13px; color: #333; line-height: 1.35; }

    .option-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 8px 0;
    }
    .option-row input[type="checkbox"] { transform: translateY(1px); }

    .font-control {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border: 1px solid #ddd;
  border-radius: 12px;
  background: #fafafa;
}
.font-control .label { font-size: 14px; font-weight: 700; color: #111; }
.font-control-row {
  display: inline-flex;
  align-items: center;
  gap: 10px;
}
.font-size-box {
  width: 70px;
  text-align: center;
  font-size: 16px;
}
.stepper {
  display: inline-flex;
  flex-direction: column;
  gap: 6px;
}
.stepper button {
  width: 36px;
  height: 32px;
  padding: 0;
  font-size: 18px;
  line-height: 1;
  border: 1px solid #ccc;
  border-radius: 8px;
  background: #fff;
  cursor: pointer;
}
.stepper button:active { transform: translateY(1px); }
.stepper button:disabled {
  background: #f0f0f0;
  color: #888;
  border-color: #ddd;
  cursor: not-allowed;
  opacity: 0.65;
}


    .adjusters-row {
      display: flex;
      gap: 12px;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
      padding-bottom: 6px;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: nowrap;
      margin: 10px 0 0 0;
      overflow-x: auto;
      padding-bottom: 4px;
    }
    button.action {
      padding: 8px 10px;
      font-size: 14px;
      white-space: nowrap;
      cursor: pointer;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
    }
    button.action:active { transform: translateY(1px); }

    .option-row {
      margin-top: 10px;
    }
    label.check {
      display: inline-flex;
      gap: 10px;
      align-items: center;
      font-size: 14px;
      user-select: none;
      cursor: pointer;
    }
    label.check input {
      width: 16px;
      height: 16px;
    }


    .divider { display: none; }

    .warning {
      display: none;
      border: 1px solid #d22;
      background: #fff5f5;
      color: #7a0a0a;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      margin: 10px 0 12px 0;
      line-height: 1.35;
    }


    .limit-msg {
      display: none;
      color: #b00000;
      font-size: 14px;
      margin-top: 10px;
      line-height: 1.35;
    }

    canvas { width: 100%; border: 1px solid #ddd; border-radius: 0; display: block; background: transparent; cursor: zoom-in; }
    canvas.rc-on { border-radius: 12px; }

    .inline-grow { flex: 1 1 520px; min-width: 260px; }
  

/* Lightbox (enlarged preview) */
.lightbox {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
.lightbox.open { display: flex; }
.lightbox-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.75);
}
.lightbox-content {
  position: relative;
  z-index: 1;
  max-width: 96vw;
  max-height: 96vh;
  padding: 16px;
}
.lightbox-img {
  display: block;
  max-width: 96vw;
  max-height: 96vh;
  height: auto;
  width: auto;
  box-shadow: 0 12px 30px rgba(0,0,0,0.35);
}
.lightbox-close {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 40px;
  height: 40px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(0,0,0,0.45);
  color: #fff;
  font-size: 26px;
  line-height: 1;
  cursor: pointer;
}
.lightbox-close:active { transform: translateY(1px); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel intro-panel">
      <h1 class="intro-heading">My review policy</h1>

      <p class="subtext">
      This YES/NO image generator helps researchers share their personal review policy in any way they want (for example, a social media post or a quick reply to unwanted review requests), including automated mass invitations, predatory journals, and high-fee for-profit publishers that rely on unpaid reviewing and often place accepted papers behind paywalls.
      <strong>#MyReviewPolicy</strong>
      &nbsp;Read more here: <a href="#" id="readMoreLink">[link coming soon]</a>
      <span class="iconbar" aria-label="Links">
        <a class="iconlink" href="https://www.linkedin.com/in/eelkedevries" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
            <path fill="#0A66C2" d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.036-1.852-3.036-1.853 0-2.136 1.445-2.136 2.939v5.666H9.35V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.368-1.85 3.6 0 4.269 2.368 4.269 5.455v6.286zM5.337 7.433a2.062 2.062 0 1 1 0-4.124 2.062 2.062 0 0 1 0 4.124zM6.815 20.452H3.858V9h2.957v11.452z"/>
          </svg>
        </a>
        <a class="iconlink" href="https://github.com/eelkedevries/" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
          <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
            <path fill="#111" d="M12 .5C5.73.5.75 5.62.75 12.05c0 5.14 3.19 9.5 7.62 11.04.56.11.77-.25.77-.56 0-.27-.01-1.17-.02-2.12-3.1.69-3.75-1.25-3.75-1.25-.5-1.33-1.23-1.68-1.23-1.68-1-.71.08-.7.08-.7 1.11.08 1.7 1.18 1.7 1.18.98 1.74 2.57 1.24 3.2.95.1-.73.38-1.24.69-1.52-2.48-.29-5.08-1.28-5.08-5.69 0-1.26.44-2.29 1.17-3.1-.12-.3-.51-1.52.11-3.16 0 0 .95-.31 3.12 1.18a10.7 10.7 0 0 1 2.84-.39c.96 0 1.93.13 2.84.39 2.17-1.49 3.12-1.18 3.12-1.18.62 1.64.23 2.86.11 3.16.73.81 1.17 1.84 1.17 3.1 0 4.42-2.61 5.39-5.1 5.68.39.35.74 1.04.74 2.11 0 1.52-.02 2.74-.02 3.11 0 .31.2.68.78.56 4.42-1.54 7.61-5.9 7.61-11.04C23.25 5.62 18.27.5 12 .5z"/>
          </svg>
        </a>
      </span>
      </p>

    </div>

<div class="panel" id="imagePanel">
<div id="overflowWarning" class="warning" role="status" aria-live="polite">
        Some text does not fit in the image at the current font sizes. Reduce the relevant font size, shorten the text, or disable header/footer.
      </div>

      <div style="margin-top:12px;">
        <canvas id="c"></canvas>
      </div>

      <div class="actions">
        <button class="action" id="downloadBtn">Download PNG</button>
        <button class="action" id="copyBtn">Copy image</button>
        <button class="action" id="copyLinkBtn">Copy link</button>
        <button class="action" id="clearBtn">Clear</button>
      </div>

      <div class="option-row">
        <label class="check"><input type="checkbox" id="roundedCorners"> Rounded corners</label>
      </div>
    </div>

<div class="panel" id="adjustPanel">
      <h2 class="section-heading">Personalize message</h2>

<div class="row">
        <div class="col">
          <label for="noText">custom NO text</label>
          <textarea id="noText">Publishing fees + paywalls</textarea>
        </div>
        <div class="col">
          <label for="yesText">custom YES text</label>
          <textarea id="yesText">Diamond open access</textarea>
        </div>
      </div>
    </div>

    


      <div class="divider"></div>
<div class="subsection">
<div class="section-box section-box--hf">
<div class="option-row">
        <input id="showHeader" type="checkbox" checked />
        <label for="showHeader" style="margin:0; font-weight:700;">Add heading text on image</label>
        <div class="inline-grow">
          <input id="headerText" type="text" value="MY PEER REVIEW POLICY" />
        </div>
      </div>

            <div class="option-row">
        <input id="showFooter" type="checkbox" />
        <label for="showFooter" style="margin:0; font-weight:700;">Add footer text below image</label>
        <div class="inline-grow">
          <input id="footerText" type="text" value="" placeholder="(optional)" />
        </div>
      </div>
</div>
    </div>

    

<div class="subsection">
      <div class="section-box section-box--sizes">
        <h3 class="subheading">Adjust text sizes</h3>
        <div class="adjusters-row" aria-label="Adjust text sizes">
        <div class="font-control" aria-label="Policy font size control">
          <div class="label">Policy</div>
          <div class="font-control-row">
            <input id="baseFontSize" class="font-size-box" type="text" inputmode="numeric" value="64" aria-label="Policy text size" />
            <div class="stepper" aria-label="Increase or decrease policy font size">
              <button id="fontPlus" type="button" aria-label="Increase policy font size">+</button>
              <button id="fontMinus" type="button" aria-label="Decrease policy font size">−</button>
            </div>
          </div>
        </div>

        <div class="font-control" aria-label="Header font size control">
          <div class="label">Header</div>
          <div class="font-control-row">
            <input id="headerFontSize" class="font-size-box" type="text" inputmode="numeric" value="40" aria-label="Header text size" />
            <div class="stepper" aria-label="Increase or decrease header font size">
              <button id="headerPlus" type="button" aria-label="Increase header font size">+</button>
              <button id="headerMinus" type="button" aria-label="Decrease header font size">−</button>
            </div>
          </div>
        </div>

        <div class="font-control" aria-label="Footer font size control">
          <div class="label">Footer</div>
          <div class="font-control-row">
            <input id="footerFontSize" class="font-size-box" type="text" inputmode="numeric" value="40" aria-label="Footer text size" />
            <div class="stepper" aria-label="Increase or decrease footer font size">
              <button id="footerPlus" type="button" aria-label="Increase footer font size">+</button>
              <button id="footerMinus" type="button" aria-label="Decrease footer font size">−</button>
            </div>
          </div>
        </div>
      </div>
      </div>
      <div id="textSizeLimitMsg" class="limit-msg" role="status" aria-live="polite"></div>
    

    
    </div>
  </div>

  <script>
    // -----------------------
    // Configuration
    // -----------------------
    const STICKER_W = 1800;
    const STICKER_H = 360;


    // Public "read more" link (update to your project page)
    const READ_MORE_URL = "https://github.com/eelkedevries/my-review-policy";
    const HEADER_H = 90;
    const FOOTER_MIN_H = 70;

    const COLORS = {
      bg: "#000000",
      sep: "#E6E6E6",
      no: "#E53935",
      yes: "#008A3B",
      text: "#FFFFFF",
      titleText: "#CFCFCF",
      headerBg: "#FFFFFF",
      headerText: "#000000",
      footerBg: "#FFFFFF",
      footerText: "#000000"
    };

    const PRESETS = {
      p1: { no: "Publishing fees + paywalls", yes: "Diamond open access" }
    };

    const DEFAULT_STATE = {
      preset: "",
      noText: PRESETS.p1.no,
      yesText: PRESETS.p1.yes,
      policyFontSize: 64,
      showHeader: true,
      headerText: "MY PEER REVIEW POLICY",
      headerFontSize: 50,
      showFooter: false,
      footerText: "",
      footerFontSize: 40,
      roundedCorners: true
    };

    // -----------------------
    // DOM
    // -----------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    // Offscreen canvas for robust "fit" checks (prevents font-size controls from exceeding available space)
    const fitCanvas = document.createElement("canvas");
    fitCanvas.width = STICKER_W;
    fitCanvas.height = STICKER_H;
    const fitCtx = fitCanvas.getContext("2d");

    let currentMaxPolicyFontSize = 140;
    let currentMaxHeaderFontSize = 140;



// Lightbox DOM (optional; guarded to avoid breaking initial render)
const lightbox = document.getElementById("lightbox");
const lightboxBackdrop = document.getElementById("lightboxBackdrop");
const lightboxClose = document.getElementById("lightboxClose");
const lightboxImg = document.getElementById("lightboxImg");

function openLightbox() {
  if (!lightbox || !lightboxImg) return;
  try { lightboxImg.src = canvas.toDataURL("image/png"); } catch (e) {}
  lightbox.classList.add("open");
  lightbox.setAttribute("aria-hidden", "false");
  document.body.style.overflow = "hidden";
}

function closeLightbox() {
  if (!lightbox) return;
  lightbox.classList.remove("open");
  lightbox.setAttribute("aria-hidden", "true");
  document.body.style.overflow = "";
}


    const readMoreLink = document.getElementById("readMoreLink");
    const noInput = document.getElementById("noText");
    const yesInput = document.getElementById("yesText");
    const presetRadios = Array.from(document.querySelectorAll('input[name="preset"]'));

    const showHeader = document.getElementById("showHeader");
    const headerTextInput = document.getElementById("headerText");

    const showFooter = document.getElementById("showFooter");
    const footerTextInput = document.getElementById("footerText");

    const roundedCorners = document.getElementById("roundedCorners");

    const baseFontSizeInput = document.getElementById("baseFontSize");
    const headerFontSizeInput = document.getElementById("headerFontSize");
    const footerFontSizeInput = document.getElementById("footerFontSize");

    const fontPlusBtn = document.getElementById("fontPlus");
    const fontMinusBtn = document.getElementById("fontMinus");
    const headerPlusBtn = document.getElementById("headerPlus");
    const headerMinusBtn = document.getElementById("headerMinus");
    const footerPlusBtn = document.getElementById("footerPlus");
    const footerMinusBtn = document.getElementById("footerMinus");

    const overflowWarning = document.getElementById("overflowWarning");
    const textSizeLimitMsg = document.getElementById("textSizeLimitMsg");

    const downloadBtn = document.getElementById("downloadBtn");
    const copyBtn = document.getElementById("copyBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const clearBtn = document.getElementById("clearBtn");

    // -----------------------
    // Helpers
    // -----------------------
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function parseIntOr(fallback, v) {
      const n = parseInt(v, 10);
      return Number.isFinite(n) ? n : fallback;
    }

    // Fast string hash for cache keys (FNV-1a, 32-bit)
    function fnv1a(str) {
      str = String(str ?? "");
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    // Cache max font sizes so we do not recompute expensive "fit" bounds on every render.
    const _maxCache = {
      policyKey: null,
      policyVal: 140,
      headerKey: null,
      headerVal: 140
    };

    function hasInImageTitle() {
      return !!(showHeader && showHeader.checked && headerTextInput && headerTextInput.value.trim().length > 0);
    }

    function showSizeLimitMessage(msg) {
      if (!textSizeLimitMsg) return;
      textSizeLimitMsg.textContent = msg;
      textSizeLimitMsg.style.display = "block";
    }
    function clearSizeLimitMessage() {
      if (!textSizeLimitMsg) return;
      textSizeLimitMsg.textContent = "";
      textSizeLimitMsg.style.display = "none";
    }


    function refreshSizeLimitMessage(maxPolicy, maxHeader) {
      // Show a persistent explanation when the user is at the maximum size for the available space.
      // We suppress the message for the initial policy auto-fit state.
      const hasTitle = (showHeader && showHeader.checked) && (headerTextInput && headerTextInput.value.trim().length > 0);

      const atPolicyMax = (getPolicyFontSize() >= (maxPolicy - 0.0001));
      const atHeaderMax = hasTitle && (getHeaderFontSize() >= (maxHeader - 0.0001));

      if (atPolicyMax && atHeaderMax) {
        showSizeLimitMessage("Heading and policy text sizes cannot be increased further because they would not fit in the image.");
        return;
      }
      if (atPolicyMax) {
        showSizeLimitMessage("Policy text size cannot be increased further because it would not fit in the image.");
        return;
      }
      if (atHeaderMax) {
        showSizeLimitMessage("Heading text size cannot be increased further because it would not fit in the image.");
        return;
      }
      clearSizeLimitMessage();
    }
    function measureSpacedTextGlobal(ctx, text, spacingPx) {
      const chars = Array.from(text || "");
      if (chars.length === 0) return 0;
      let w = 0;
      for (let i = 0; i < chars.length; i++) {
        w += ctx.measureText(chars[i]).width;
        if (i < chars.length - 1) w += spacingPx;
      }
      return w;
    }
    function getTitleSpacingPxGlobal(sizePx) {
      return Math.max(4, Math.min(10, Math.round(sizePx * 0.14)));
    }



    
    
    function pathRoundRect(ctx, x, y, w, h, r) {
      const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    // Auto-fit policy text size until the user manually changes it
    let policyAutoFit = true;

    function getPolicyFontSize() { return clamp(parseIntOr(DEFAULT_STATE.policyFontSize, baseFontSizeInput.value), 10, 140); }
    function setPolicyFontSize(n, maxOverride) {
      const max = Number.isFinite(maxOverride) ? maxOverride : computeMaxPolicyFontSize();
      baseFontSizeInput.value = clamp(n, 10, Math.max(10, Math.min(140, max)));
    }

    function getHeaderFontSize() { return clamp(parseIntOr(DEFAULT_STATE.headerFontSize, headerFontSizeInput.value), 10, 140); }
    function setHeaderFontSize(n, maxOverride) {
      const max = Number.isFinite(maxOverride) ? maxOverride : computeMaxHeaderFontSize();
      headerFontSizeInput.value = clamp(n, 10, Math.max(10, Math.min(140, max)));
    }

    function getFooterFontSize() { return clamp(parseIntOr(DEFAULT_STATE.footerFontSize, footerFontSizeInput.value), 10, 140); }
    function setFooterFontSize(n) { footerFontSizeInput.value = clamp(n, 10, 140); }

    function updateTextSizeStepperStates() {
      if (fontPlusBtn) fontPlusBtn.disabled = getPolicyFontSize() >= currentMaxPolicyFontSize;
      if (headerPlusBtn) headerPlusBtn.disabled = getHeaderFontSize() >= currentMaxHeaderFontSize;
    }

    function bumpPolicy(delta) {
      policyAutoFit = false;
      const max = computeCorrectedMaxPolicyFontSize();
      const desired = getPolicyFontSize() + delta;

      if (delta > 0) {
        setPolicyFontSize(Math.min(desired, max), max);
      } else {
        setPolicyFontSize(desired, max);
      }
      renderAll();
    }

    function bumpHeader(delta) {
      const max = computeCorrectedMaxHeaderFontSize();
      const desired = getHeaderFontSize() + delta;

      if (delta > 0) {
        setHeaderFontSize(Math.min(desired, max), max);
      } else {
        setHeaderFontSize(desired, max);
      }
      renderAll();
    }

    function bumpFooter(delta) {
      setFooterFontSize(getFooterFontSize() + delta);
      renderAll();
    }

    function getCurrentState() {
      return {
        preset: getSelectedPresetKey(),
        noText: noInput.value,
        yesText: yesInput.value,
        policyFontSize: getPolicyFontSize(),
        showHeader: !!showHeader.checked,
        headerText: headerTextInput.value,
        headerFontSize: getHeaderFontSize(),
        showFooter: !!showFooter.checked,
        footerText: footerTextInput.value,
        footerFontSize: getFooterFontSize(),
        roundedCorners: !!roundedCorners.checked
      };
    }

    function applyState(s) {
      if (!s || typeof s !== "object") return;

      // Preset selection (cosmetic; text fields are authoritative)
      if (typeof s.preset === "string" && s.preset.length) {
        presetRadios.forEach(r => { r.checked = (r.value === s.preset); });
      } else {
        clearPresetSelection();
      }

      if (typeof s.noText === "string") noInput.value = s.noText;
      if (typeof s.yesText === "string") yesInput.value = s.yesText;

      if (typeof s.policyFontSize === "number") setPolicyFontSize(s.policyFontSize);
      if (typeof s.headerFontSize === "number") setHeaderFontSize(s.headerFontSize);
      if (typeof s.footerFontSize === "number") setFooterFontSize(s.footerFontSize);

      if (typeof s.showHeader === "boolean") showHeader.checked = s.showHeader;
      if (typeof s.headerText === "string") headerTextInput.value = s.headerText;

      if (typeof s.showFooter === "boolean") showFooter.checked = s.showFooter;
      if (typeof s.footerText === "string") footerTextInput.value = s.footerText;

      if (typeof s.roundedCorners === "boolean" && roundedCorners) roundedCorners.checked = s.roundedCorners;

      renderAll();
    }

    function stateToSearchParams(s) {
      const sp = new URLSearchParams();
      if (!s) return sp;

      // Keep keys short for cleaner URLs
      if (s.preset) sp.set("p", s.preset);
      sp.set("no", s.noText || "");
      sp.set("yes", s.yesText || "");
      sp.set("pfs", String(s.policyFontSize || DEFAULT_STATE.policyFontSize));

      sp.set("sh", s.showHeader ? "1" : "0");
      sp.set("ht", s.headerText || "");
      sp.set("hfs", String(s.headerFontSize || DEFAULT_STATE.headerFontSize));

      sp.set("sf", s.showFooter ? "1" : "0");
      sp.set("ft", s.footerText || "");
      sp.set("ffs", String(s.footerFontSize || DEFAULT_STATE.footerFontSize));

      sp.set("rc", s.roundedCorners ? "1" : "0");

      return sp;
    }

    function parseStateFromQuery() {
      const sp = new URLSearchParams(window.location.search);

      // If none of our keys are present, treat as "no state".
      const keys = ["p", "no", "yes", "pfs", "sh", "ht", "hfs", "sf", "ft", "ffs", "rc"];
      const hasAny = keys.some(k => sp.has(k));
      if (!hasAny) return null;

      const s = {
        preset: sp.get("p") || "",
        noText: sp.get("no") ?? DEFAULT_STATE.noText,
        yesText: sp.get("yes") ?? DEFAULT_STATE.yesText,
        policyFontSize: parseIntOr(DEFAULT_STATE.policyFontSize, sp.get("pfs")),
        showHeader: (sp.get("sh") ?? (DEFAULT_STATE.showHeader ? "1" : "0")) === "1",
        headerText: sp.get("ht") ?? DEFAULT_STATE.headerText,
        headerFontSize: parseIntOr(DEFAULT_STATE.headerFontSize, sp.get("hfs")),
        showFooter: (sp.get("sf") ?? (DEFAULT_STATE.showFooter ? "1" : "0")) === "1",
        footerText: sp.get("ft") ?? DEFAULT_STATE.footerText,
        footerFontSize: parseIntOr(DEFAULT_STATE.footerFontSize, sp.get("ffs")),
        roundedCorners: (sp.get("rc") ?? (DEFAULT_STATE.roundedCorners ? "1" : "0")) === "1"
      };

      return s;
    }

    function applyStateFromQuery() {
      const sp = new URLSearchParams(window.location.search);
      const s = parseStateFromQuery();
      if (s) {
        // If the share link does not specify policy font size, auto-fit it.
        policyAutoFit = !sp.has("pfs");
        applyState(s);

        // If the share link does not specify heading font size, default to 80% of the maximum that fits.
        if (!sp.has("hfs")) {
          const _maxHeaderDefault = computeCorrectedMaxHeaderFontSize();
          setHeaderFontSize(Math.max(10, Math.floor(_maxHeaderDefault * 0.8)), _maxHeaderDefault);
          renderAll();
        }
      }
    }
    // -----------------------
    // Wrapping preserving spaces/newlines + breaking long words
    // -----------------------
    function splitPreserveNewlines(text) { return (text || "").split(/\r?\n/); }
    function tokenizePreserveSpaces(s) { return (s || "").match(/(\s+|\S+)/g) || []; }

    function breakTokenToFit(ctx, token, maxWidth) {
      const parts = [];
      let cur = "";
      for (const ch of token) {
        const test = cur + ch;
        if (ctx.measureText(test).width <= maxWidth || cur.length === 0) cur = test;
        else { parts.push(cur); cur = ch; }
      }
      if (cur) parts.push(cur);
      return parts;
    }

    function wrapTextNoLimit(ctx, text, maxWidth, fontSize) {
      ctx.font = `bold ${fontSize}px Arial`;
      const paragraphs = splitPreserveNewlines(text);
      const lines = [];

      for (let pi = 0; pi < paragraphs.length; pi++) {
        const para = paragraphs[pi];
        const tokens = tokenizePreserveSpaces(para);

        if (tokens.length === 0 && para.length === 0) { lines.push(""); continue; }

        let line = "";

        for (const tok of tokens) {
          const isSpace = /^\s+$/.test(tok);
          if (line.length === 0 && isSpace) continue;

          if (!isSpace && ctx.measureText(tok).width > maxWidth) {
            const pieces = breakTokenToFit(ctx, tok, maxWidth);
            for (const piece of pieces) {
              const test = line ? (line + piece) : piece;
              if (ctx.measureText(test).width <= maxWidth || line.length === 0) line = test;
              else { lines.push(line); line = piece; }
            }
            continue;
          }

          const test = line + tok;
          if (ctx.measureText(test).width <= maxWidth || line.length === 0) line = test;
          else { lines.push(line); line = isSpace ? "" : tok; }
        }

        if (line !== "") lines.push(line);
      }

      return lines;
    }


    // -----------------------
    // Auto-fit policy text size
    // -----------------------
    
    function computeMaxPolicyFontSize() {
      const W = STICKER_W;
      const H = STICKER_H;

      // Geometry mirrors drawSticker() so that "fits" matches actual rendering.
      const sepW = Math.max(4, Math.round(W * 0.003));
      const border = 0;

      const padOuter = Math.round(W * 0.014);
      const padSep = Math.round(W * 0.024);
      const labelBlockW = Math.round(W * 0.16);

      const innerH = H - 2 * border;
      const totalInnerW = W - 2 * border;
      const textAreaW = (totalInnerW - 2 * labelBlockW - sepW) / 2;

      const noTextW = textAreaW - padOuter - padSep;
      const yesTextW = textAreaW - padOuter - padSep;

      const hasTitle = hasInImageTitle();

      const clipTop = border + (hasTitle ? Math.round(H * 0.26) : Math.round(H * 0.12));
      const clipBottom = border + innerH - Math.round(H * 0.08);
      const clipH = Math.max(0, clipBottom - clipTop);

      const yMid = border + innerH / 2;

      function fits(fontSize) {
        const lineGap = Math.round(fontSize * 0.18);
        const lh = fontSize + lineGap;
        if (lh <= 0) return false;

        // Wrap text at this font size
        const noLines = wrapTextNoLimit(fitCtx, noInput.value, noTextW, fontSize);
        const yesLines = wrapTextNoLimit(fitCtx, yesInput.value, yesTextW, fontSize);

        // Match drawSticker() vertical centring logic
        const maxLinesClip = Math.max(0, Math.floor(clipH / lh));

        function computeDrawY(lineCount) {
          const visibleLines = Math.min(lineCount, maxLinesClip);
          const visibleH = visibleLines * lh;
          let y = yMid - (visibleH / 2);
          y = Math.max(clipTop, Math.min(y, clipBottom - visibleH));
          return y;
        }

        const noDrawY = computeDrawY(noLines.length);
        const yesDrawY = computeDrawY(yesLines.length);

        const noAvailH = (clipTop + clipH) - noDrawY;
        const yesAvailH = (clipTop + clipH) - yesDrawY;

        const noMaxLinesFit = Math.max(0, Math.floor(noAvailH / lh));
        const yesMaxLinesFit = Math.max(0, Math.floor(yesAvailH / lh));

        if (noLines.length > noMaxLinesFit) return false;
        if (yesLines.length > yesMaxLinesFit) return false;

        // Horizontal safety check
        fitCtx.font = `bold ${fontSize}px Arial`;
        for (const ln of noLines) if (fitCtx.measureText(ln).width > noTextW + 0.5) return false;
        for (const ln of yesLines) if (fitCtx.measureText(ln).width > yesTextW + 0.5) return false;

        return true;
      }

      // Binary search for the largest font size that fits.
      let lo = 10, hi = 140, best = 10;
      while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (fits(mid)) { best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      return best;
    }

    
    function computeMaxHeaderFontSize() {
      const hasTitle = hasInImageTitle();
      if (!hasTitle) return 140;

      const W = STICKER_W;
      const H = STICKER_H;

      const labelBlockW = Math.round(W * 0.16);
      const titleAreaW = W - 2 * labelBlockW;
      const titleAreaH = Math.round(H * 0.20);

      const title = headerTextInput.value.trim();

      function fits(hfs) {
        let titleSize = Math.round(hfs * 0.65);
        titleSize = Math.max(16, Math.min(titleSize, 140));

        // Height constraint mirrors drawSticker()
        if (titleSize > titleAreaH * 0.78) return false;

        fitCtx.font = `600 ${titleSize}px Arial`;
        const spacingPx = getTitleSpacingPxGlobal(titleSize);

        // Width constraint mirrors drawSticker()
        return measureSpacedTextGlobal(fitCtx, title, spacingPx) <= titleAreaW * 0.94;
      }

      // Binary search for max hfs that fits.
      let lo = 10, hi = 140, best = 10;
      while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        if (fits(mid)) { best = mid; lo = mid + 1; }
        else { hi = mid - 1; }
      }
      return best;
    }


    
    function computeCorrectedMaxHeaderFontSize() {
      const hasTitle = hasInImageTitle();
      const title = hasTitle ? headerTextInput.value.trim() : "";
      const key = hasTitle ? (`1|${fnv1a(title)}`) : "0";

      if (_maxCache.headerKey === key) return _maxCache.headerVal;

      const val = computeMaxHeaderFontSize();
      _maxCache.headerKey = key;
      _maxCache.headerVal = val;
      return val;
    }

    
    function computeCorrectedMaxPolicyFontSize() {
      const hasTitle = hasInImageTitle();
      const key = `${fnv1a(noInput.value)}|${fnv1a(yesInput.value)}|${hasTitle ? 1 : 0}`;

      if (_maxCache.policyKey === key) return _maxCache.policyVal;

      const val = computeMaxPolicyFontSize();
      _maxCache.policyKey = key;
      _maxCache.policyVal = val;
      return val;
    }

function drawTextBlockClipped(opts) {
      const { ctx, text, x, y, w, h, fontSize, lineGap, align, fillStyle } = opts;
      const clipY = y;
      const drawY = (typeof opts.drawY === "number") ? opts.drawY : y;

      ctx.save();
      ctx.beginPath();
      ctx.rect(x, clipY, w, h);
      ctx.clip();

      ctx.font = `bold ${fontSize}px Arial`;
      ctx.fillStyle = fillStyle;
      ctx.textBaseline = "top";
      ctx.textAlign = align;

      const maxWidth = w;
      const lines = wrapTextNoLimit(ctx, text, maxWidth, fontSize);

      const lh = fontSize + lineGap;
      const availableH = Math.max(0, (clipY + h) - drawY);
      const maxLinesThatFit = Math.max(0, Math.floor(availableH / lh));
      const willOverflowVert = lines.length > maxLinesThatFit;

      let cy = drawY;
      for (let i = 0; i < Math.min(lines.length, maxLinesThatFit); i++) {
        const line = lines[i];
        let tx = x;
        if (align === "right") tx = x + w;
        if (align === "center") tx = x + w / 2;
        ctx.fillText(line, tx, cy);
        cy += lh;
      }

      ctx.restore();

      ctx.font = `bold ${fontSize}px Arial`;
      let willOverflowHoriz = false;
      for (const ln of lines) {
        if (ctx.measureText(ln).width > maxWidth + 0.5) { willOverflowHoriz = true; break; }
      }

      return { overflow: willOverflowVert || willOverflowHoriz };
    }

    function fitLabelFontSize(ctx, labelBlockW, innerH) {
      const maxW = labelBlockW * 0.86;
      const maxH = innerH * 0.80;
      let size = Math.floor(innerH * 0.62);

      while (size > 20) {
        ctx.font = `bold ${size}px Arial`;
        const yesW = ctx.measureText("YES").width;
        const noW  = ctx.measureText("NO").width;
        if (yesW <= maxW && noW <= maxW && size <= maxH) return size;
        size -= 2;
      }
      return 20;
    }

    // -----------------------
    // Drawing
    // -----------------------
    function drawHeaderBand(ctx, W, headerH, text, fontSizeFixed) {
      ctx.fillStyle = COLORS.headerBg;
      ctx.fillRect(0, 0, W, headerH);

      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, W, headerH);
      ctx.clip();

      ctx.font = `bold ${fontSizeFixed}px Arial`;
      ctx.fillStyle = COLORS.headerText;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, W / 2, headerH / 2);

      const overflow = ctx.measureText(text).width > W * 0.92;

      ctx.restore();
      return { overflow };
    }

    function computeFooterHeight(text, fontSize) {
      const W = STICKER_W;
      const padX = Math.round(W * 0.04);
      const maxW = Math.max(0, W - 2 * padX);

      const lineGap = Math.round(fontSize * 0.22);
      const lh = fontSize + lineGap;

      const lines = wrapTextNoLimit(ctx, text || "", maxW, fontSize);
      const padY = Math.max(14, Math.round(fontSize * 0.55));

      const h = padY * 2 + lines.length * lh;
      return Math.max(FOOTER_MIN_H, Math.ceil(h));
    }

    function drawFooterBandWrapped(ctx, W, footerH, yOffset, text, fontSizeFixed) {
      ctx.fillStyle = COLORS.footerBg;
      ctx.fillRect(0, yOffset, W, footerH);

      ctx.save();
      ctx.beginPath();
      ctx.rect(0, yOffset, W, footerH);
      ctx.clip();

      const padX = Math.round(W * 0.04);
      const maxW = Math.max(0, W - 2 * padX);

      ctx.font = `bold ${fontSizeFixed}px Arial`;
      ctx.fillStyle = COLORS.footerText;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";

      const lineGap = Math.round(fontSizeFixed * 0.22);
      const lh = fontSizeFixed + lineGap;

      const lines = wrapTextNoLimit(ctx, text || "", maxW, fontSizeFixed).map(s => (s || "").trim());
      const textH = lines.length * lh;

      const minPadY = Math.max(14, Math.round(fontSizeFixed * 0.55));
      let y = yOffset + Math.max(minPadY, (footerH - textH) / 2);

      for (const line of lines) {
        ctx.fillText(line, W / 2, y);
        y += lh;
      }

      ctx.restore();
      return { overflow: false };
    }


    function drawSticker(ctx, W, H, policyFontSize, headerFontSize) {
      // Center separator: thinner and less dominant
      const sepW = Math.max(4, Math.round(W * 0.003));


      // No outer outline/border now
      const border = 0;

      const padOuter = Math.round(W * 0.014);
      const padSep = Math.round(W * 0.024);
      const labelBlockW = Math.round(W * 0.16);
      const innerH = H - 2 * border;
      const totalInnerW = W - 2 * border;
      const textAreaW = (totalInnerW - 2 * labelBlockW - sepW) / 2;

      const xNoBlock = border;
      const xNoText = border + labelBlockW;
      const xSep = xNoText + textAreaW;
      const xYesText = xSep + sepW;
      const xYesBlock = xYesText + textAreaW;

      // Background
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, W, H);

      // Separator (shorter height, not full)
      const hasTitle = showHeader.checked && headerTextInput.value.trim().length > 0;
      const sepTopPad = hasTitle ? Math.round(H * 0.20) : Math.round(H * 0.08);
      const sepBottomPad = Math.round(H * 0.10);
      const sepY = border + sepTopPad;
      const sepH = innerH - sepTopPad - sepBottomPad;

      ctx.fillStyle = COLORS.sep;
      ctx.fillRect(xSep, sepY, sepW, sepH);

      // Blocks
      ctx.fillStyle = COLORS.no;
      ctx.fillRect(xNoBlock, border, labelBlockW, innerH);

      ctx.fillStyle = COLORS.yes;
      ctx.fillRect(xYesBlock, border, labelBlockW, innerH);

      // YES/NO labels
      ctx.fillStyle = COLORS.text;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const labelFontSize = fitLabelFontSize(ctx, labelBlockW, innerH);
      ctx.font = `bold ${labelFontSize}px Arial`;
      ctx.fillText("NO", xNoBlock + labelBlockW / 2, H / 2);
      ctx.fillText("YES", xYesBlock + labelBlockW / 2, H / 2);

      // In-image title (drawn in the central black area, above the policy text)
      let titleOverflow = false;
      if (hasTitle) {
        const title = headerTextInput.value.trim();

        // Clip to the central black area so it never spills into the NO/YES colour blocks
        const titleAreaX = xNoText;
        const titleAreaW = W - 2 * labelBlockW;
        const titleAreaY = border;
        const titleAreaH = Math.max(0, sepY - border);

        ctx.save();
        ctx.beginPath();
        ctx.rect(titleAreaX, titleAreaY, titleAreaW, titleAreaH);
        ctx.clip();

        // Smaller than the old external header band
        // Letter spacing for a cleaner "label" look (canvas has no native letter-spacing)
        function measureSpacedText(ctx, text, spacingPx) {
          const chars = Array.from(text);
          if (chars.length === 0) return 0;
          let w = 0;
          for (let i = 0; i < chars.length; i++) {
            w += ctx.measureText(chars[i]).width;
            if (i < chars.length - 1) w += spacingPx;
          }
          return w;
        }

        function drawCenteredSpacedText(ctx, text, cx, cy, spacingPx) {
          const prevAlign = ctx.textAlign;
          ctx.textAlign = "left";
          const chars = Array.from(text);
          if (chars.length === 0) { ctx.textAlign = prevAlign; return; }
          const widths = chars.map(ch => ctx.measureText(ch).width);
          const totalW = widths.reduce((a,b)=>a+b,0) + spacingPx * (chars.length - 1);
          let x = cx - totalW / 2;
          for (let i = 0; i < chars.length; i++) {
            ctx.fillText(chars[i], x, cy);
            x += widths[i] + spacingPx;
          }
          ctx.textAlign = prevAlign;
        }

        let titleSize = Math.round(headerFontSize * 0.65);
        titleSize = Math.max(16, Math.min(titleSize, 140));

        // Increase letter spacing and scale it with font size (clamped)
        const getTitleSpacingPx = (sizePx) => Math.max(4, Math.min(10, Math.round(sizePx * 0.14)));

        ctx.font = `600 ${titleSize}px Arial`;
        const titleSpacingPx = getTitleSpacingPx(titleSize);

        const tooWide = measureSpacedText(ctx, title, titleSpacingPx) > titleAreaW * 0.94;
        const tooTall = titleSize > titleAreaH * 0.78;
        titleOverflow = (tooWide || tooTall);
ctx.fillStyle = COLORS.titleText;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        drawCenteredSpacedText(ctx, title, titleAreaX + titleAreaW / 2, titleAreaY + titleAreaH / 2, titleSpacingPx);

        ctx.restore();
      }


      // Text areas (clipped, no shrink)
      // Vertically centre each text block so it aligns with the NO/YES labels.
      const lineGap = Math.round(policyFontSize * 0.18);
      const lh = policyFontSize + lineGap;

      // Safe clip region: keep text below the in-image title and away from the bottom edge.
      const clipTop = border + (hasTitle ? Math.round(H * 0.26) : Math.round(H * 0.12));
      const clipBottom = border + innerH - Math.round(H * 0.08);
      const clipH = Math.max(0, clipBottom - clipTop);

      // Target vertical centre (same as YES/NO labels).
      const yMid = border + innerH / 2;

      // Padding: more space around the centre divider
      const noTextX = xNoText + padOuter;
      const noTextW = textAreaW - padOuter - padSep;
      const yesTextX = xYesText + padSep;
      const yesTextW = textAreaW - padOuter - padSep;

      function computeDrawY(text, width) {
        const lines = wrapTextNoLimit(ctx, text, width, policyFontSize);
        const maxLines = Math.max(0, Math.floor(clipH / lh));
        const visibleLines = Math.min(lines.length, maxLines);
        const visibleH = visibleLines * lh;
        let y = yMid - (visibleH / 2);
        y = Math.max(clipTop, Math.min(y, clipBottom - visibleH));
        return y;
      }

      const noDrawY = computeDrawY(noInput.value, noTextW);
      const yesDrawY = computeDrawY(yesInput.value, yesTextW);

      const noOverflow = drawTextBlockClipped({
        ctx,
        text: noInput.value,
        x: noTextX,
        y: clipTop,
        w: noTextW,
        h: clipH,
        drawY: noDrawY,
        fontSize: policyFontSize,
        lineGap,
        align: "left",
        fillStyle: COLORS.text
      }).overflow;

      const yesOverflow = drawTextBlockClipped({
        ctx,
        text: yesInput.value,
        x: yesTextX,
        y: clipTop,
        w: yesTextW,
        h: clipH,
        drawY: yesDrawY,
        fontSize: policyFontSize,
        lineGap,
        align: "right",
        fillStyle: COLORS.text
      }).overflow;

return { overflow: (noOverflow || yesOverflow || titleOverflow), noOverflow, yesOverflow, titleOverflow };
    }

    function setCanvasSizeAndRender() {
      const hasFooter = showFooter.checked;
      const footerH = hasFooter ? computeFooterHeight(footerTextInput.value, getFooterFontSize()) : 0;

      // The header text is rendered inside the main image (sticker), so we do not add an extra header band height.
      const totalH = STICKER_H + footerH;
      canvas.width = STICKER_W;
      canvas.height = totalH;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const useRounded = !!(roundedCorners && roundedCorners.checked);
      canvas.classList.toggle("rc-on", useRounded);
      const cornerR = Math.max(16, Math.min(42, Math.round(Math.min(canvas.width, canvas.height) * 0.06)));
      if (useRounded) {
        ctx.save();
        pathRoundRect(ctx, 0, 0, canvas.width, canvas.height, cornerR);
        ctx.clip();
      }

      let overflow = false;

      const stickerOverflow = drawSticker(ctx, STICKER_W, STICKER_H, getPolicyFontSize(), getHeaderFontSize());
      overflow = overflow || stickerOverflow.overflow;

      if (hasFooter) {
        const footerOverflow = drawFooterBandWrapped(ctx, STICKER_W, footerH, STICKER_H, footerTextInput.value, getFooterFontSize());
        overflow = overflow || footerOverflow.overflow;
      }

      if (useRounded) {
        ctx.restore();

        // Hard mask to guarantee that the cut-out corner areas are transparent in the PNG export.
        // (Some viewers display transparency as white; this ensures the alpha channel is present.)
        ctx.save();
        ctx.globalCompositeOperation = "destination-in";
        ctx.fillStyle = "#000";
        pathRoundRect(ctx, 0, 0, canvas.width, canvas.height, cornerR);
        ctx.fill();
        ctx.restore();
      }

      overflowWarning.style.display = overflow ? "block" : "none";
      return { overflow, stickerOverflow };
    }



    // -----------------------
    // Defaults
    // -----------------------
    function clearPresetSelection() { presetRadios.forEach(r => r.checked = false); }

    function applyPresetKey(key) {
      const p = PRESETS[key];
      if (!p) return;
      noInput.value = p.no;
      yesInput.value = p.yes;
    }

    
    function setDefaults() {
      policyAutoFit = true;

      clearPresetSelection();
      noInput.value = DEFAULT_STATE.noText;
      yesInput.value = DEFAULT_STATE.yesText;

      showHeader.checked = DEFAULT_STATE.showHeader;
      headerTextInput.value = DEFAULT_STATE.headerText;

      // Default: 80% of the maximum heading size that fits in the image
      const _maxHeaderDefault = computeCorrectedMaxHeaderFontSize();
      setHeaderFontSize(Math.max(10, Math.floor(_maxHeaderDefault * 0.8)), _maxHeaderDefault);

      showFooter.checked = DEFAULT_STATE.showFooter;
      footerTextInput.value = DEFAULT_STATE.footerText;
      setFooterFontSize(DEFAULT_STATE.footerFontSize);


      if (roundedCorners) roundedCorners.checked = DEFAULT_STATE.roundedCorners;

      // Default: 95% of the maximum policy text size that fits in the image (until the user overrides it)
      const _maxPolicyDefault = computeCorrectedMaxPolicyFontSize();
      setPolicyFontSize(Math.max(10, Math.floor(_maxPolicyDefault * 0.95)), _maxPolicyDefault);

      renderAll();
    }

        function renderAll() {
      const maxHeader = computeCorrectedMaxHeaderFontSize();
      const maxPolicy = computeCorrectedMaxPolicyFontSize();

      currentMaxPolicyFontSize = maxPolicy;
      currentMaxHeaderFontSize = maxHeader;

      let clampedPolicy = false;
      let clampedHeader = false;

      if (policyAutoFit) {
        const target = Math.max(10, Math.floor(maxPolicy * 0.95));
        setPolicyFontSize(target, maxPolicy);
      } else if (getPolicyFontSize() > maxPolicy) {
        setPolicyFontSize(maxPolicy, maxPolicy);
        clampedPolicy = true;
      }

      if (getHeaderFontSize() > maxHeader) {
        setHeaderFontSize(maxHeader, maxHeader);
        clampedHeader = true;
      }

      if (clampedPolicy && clampedHeader) {
        showSizeLimitMessage("Heading and policy text sizes were reduced to fit in the image.");
      } else if (clampedPolicy) {
        showSizeLimitMessage("Policy text size was reduced to fit in the image.");
      } else if (clampedHeader) {
        showSizeLimitMessage("Heading text size was reduced to fit in the image.");
      } else {
        refreshSizeLimitMessage(maxPolicy, maxHeader);
      }

      updateTextSizeStepperStates();
      setCanvasSizeAndRender();
    }

    // -----------------------
    // Export / clipboard
    // -----------------------
    function canvasToBlob(type = "image/png", quality) {
      return new Promise((resolve) => {
        try {
          canvas.toBlob((b) => resolve(b), type, quality);
        } catch (e) {
          console.error(e);
          resolve(null);
        }
      });
    }

    async function downloadPNG() {
      // Prefer Blob/ObjectURL (more robust than data: URLs across browsers)
      try {
        const blob = await canvasToBlob("image/png");
        if (!blob) throw new Error("Could not create image blob.");
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.download = "my-review-policy.png";
        a.href = url;
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        a.remove();

        // Revoke after click has been dispatched
        setTimeout(() => URL.revokeObjectURL(url), 1500);
        return;
      } catch (e) {
        console.error(e);
      }

      // Fallback: data URL
      try {
        const a = document.createElement("a");
        a.download = "my-review-policy.png";
        a.href = canvas.toDataURL("image/png");
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        a.remove();
      } catch (e) {
        console.error(e);
        alert("Download failed in this browser context. Try opening the page via HTTPS (e.g., GitHub Pages) and try again.");
      }
    }

    function openPNGInNewTab() {
      try {
        const url = canvas.toDataURL("image/png");
        window.open(url, "_blank", "noopener,noreferrer");
      } catch (e) {
        console.error(e);
      }
    }

    async function copyImage() {
      // Clipboard image write requires a secure context (HTTPS / localhost) in most browsers.
      if (!window.isSecureContext) {
        alert("Copy image requires a secure context (HTTPS). Use “Download PNG” instead.");
        return;
      }

      try {
        if (!navigator.clipboard || !window.ClipboardItem) {
          alert("Clipboard image copy is not supported in this browser. Use “Download PNG” instead.");
          return;
        }

        const blob = await canvasToBlob("image/png");
        if (!blob) { alert("Could not create image blob. Use “Download PNG” instead."); return; }

        await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
        alert("Image copied to clipboard.");
      } catch (e) {
        console.error(e);
        // As a practical fallback, open the PNG in a new tab so users can use browser-native copy/save.
        openPNGInNewTab();
        alert("Copy failed. I opened the PNG in a new tab as a fallback (you can copy/save from there).");
      }
    }


    async function copyLinkRobust() {
      const base = (window.location.origin && window.location.origin !== "null")
        ? (window.location.origin + window.location.pathname)
        : window.location.href.split("?")[0].split("#")[0];

      const sp = stateToSearchParams(getCurrentState());
      const qs = sp.toString();
      const url = qs ? (base + "?" + qs) : base;
try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(url);
          alert("Link copied to clipboard.");
          return;
        }
      } catch (e) {}

      try {
        const tmp = document.createElement("textarea");
        tmp.value = url;
        tmp.setAttribute("readonly", "");
        tmp.style.position = "fixed";
        tmp.style.left = "-9999px";
        tmp.style.top = "0";
        document.body.appendChild(tmp);
        tmp.select();
        tmp.setSelectionRange(0, tmp.value.length);
        const ok = document.execCommand("copy");
        document.body.removeChild(tmp);
        if (ok) alert("Link copied to clipboard.");
        else alert("Copy failed. Please copy from the address bar.");
      } catch (e) {
        alert("Copy failed. Please copy from the address bar.");
      }
    }

    // -----------------------
    // Events
    // -----------------------
    function onAnyChange() { renderAll(); }

    presetRadios.forEach(radio => {
      radio.addEventListener("change", () => { applyPresetKey(radio.value); clearSizeLimitMessage(); onAnyChange(); });
    });

    noInput.addEventListener("input", () => { clearSizeLimitMessage(); onAnyChange(); });
    yesInput.addEventListener("input", () => { clearSizeLimitMessage(); onAnyChange(); });

    showHeader.addEventListener("change", () => { clearSizeLimitMessage(); onAnyChange(); });
    headerTextInput.addEventListener("input", () => { clearSizeLimitMessage(); onAnyChange(); });

    showFooter.addEventListener("change", () => { clearSizeLimitMessage(); onAnyChange(); });
    footerTextInput.addEventListener("input", () => { clearSizeLimitMessage(); onAnyChange(); });

    if (roundedCorners) roundedCorners.addEventListener("change", () => { clearSizeLimitMessage(); onAnyChange(); });

    baseFontSizeInput.addEventListener("input", () => {
      policyAutoFit = false;
      const desired = getPolicyFontSize();
      const max = computeCorrectedMaxPolicyFontSize();
      if (desired > max) {
        setPolicyFontSize(max, max);
        showSizeLimitMessage("Policy text size cannot be increased further because it would not fit in the image.");
      } else {
        setPolicyFontSize(desired, max);
        clearSizeLimitMessage();
      }
      onAnyChange();
    });
    headerFontSizeInput.addEventListener("input", () => {
      const desired = getHeaderFontSize();
      const max = computeCorrectedMaxHeaderFontSize();
      if (desired > max) {
        setHeaderFontSize(max, max);
        showSizeLimitMessage("Heading text size cannot be increased further because it would not fit in the image.");
      } else {
        setHeaderFontSize(desired, max);
        clearSizeLimitMessage();
      }
      onAnyChange();
    });
    footerFontSizeInput.addEventListener("input", () => { setFooterFontSize(getFooterFontSize()); onAnyChange(); });

    fontPlusBtn.addEventListener("click", () => bumpPolicy(+2));
    fontMinusBtn.addEventListener("click", () => bumpPolicy(-2));

    headerPlusBtn.addEventListener("click", () => bumpHeader(+2));
    headerMinusBtn.addEventListener("click", () => bumpHeader(-2));

    footerPlusBtn.addEventListener("click", () => bumpFooter(+2));
    footerMinusBtn.addEventListener("click", () => bumpFooter(-2));

    downloadBtn.addEventListener("click", downloadPNG);
    copyBtn.addEventListener("click", copyImage);
    copyLinkBtn.addEventListener("click", copyLinkRobust);
    clearBtn.addEventListener("click", setDefaults);



// Lightbox events (guarded)
if (lightbox && lightboxBackdrop && lightboxClose && lightboxImg) {
  canvas.addEventListener("click", openLightbox);
  lightboxBackdrop.addEventListener("click", closeLightbox);
  lightboxClose.addEventListener("click", closeLightbox);
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && lightbox.classList.contains("open")) closeLightbox();
  });
}

    window.addEventListener("resize", setCanvasSizeAndRender);

    // Init: defaults, then share-link state, then a couple of re-renders for mobile Chrome
    setDefaults();
    applyStateFromQuery();
    requestAnimationFrame(renderAll);
    setTimeout(renderAll, 50);
    window.addEventListener("load", () => { requestAnimationFrame(renderAll); });

    // Wire the "read more" link for GitHub Pages
    if (readMoreLink) {
      readMoreLink.href = READ_MORE_URL;
      readMoreLink.textContent = READ_MORE_URL;
    }

    // Share-link state is applied during init above.
  </script>


<div class="lightbox" id="lightbox" aria-hidden="true">
  <div class="lightbox-backdrop" id="lightboxBackdrop"></div>
  <div class="lightbox-content" role="dialog" aria-modal="true" aria-label="Enlarged image preview">
    <button class="lightbox-close" id="lightboxClose" type="button" aria-label="Close">×</button>
    <img class="lightbox-img" id="lightboxImg" alt="Enlarged preview" />
  </div>
</div>
</body>
</html>
