<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YES/NO Sticker Generator</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 24px; color: #111; }
    .wrap { max-width: 1040px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; margin: 12px 0; align-items: end; }
    .col { flex: 1 1 420px; }
    label { display: block; font-size: 14px; margin-bottom: 6px; }
    input[type="text"], select {
      width: 100%; padding: 10px 12px; font-size: 16px;
      border: 1px solid #ccc; border-radius: 8px; background: #fff;
    }
    button {
      padding: 10px 14px; font-size: 16px; cursor: pointer;
      border: 1px solid #ccc; border-radius: 8px; background: #fff;
    }
    button:active { transform: translateY(1px); }
    canvas { width: 100%; border: 1px solid #ddd; border-radius: 12px; display: block; }
    .links { margin-top: 10px; font-size: 14px; }
    .links a { color: #0b65c2; text-decoration: none; }
    .links a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>YES/NO Sticker Generator</h2>

    <div class="row">
      <div class="col">
        <label for="presetSelect">Presets</label>
        <select id="presetSelect">
          <option value="">Select a presetâ€¦</option>
          <option value="diamond">Diamond OA vs paywalls/APCs</option>
          <option value="nonprofit">Non-profit vs publisher profit</option>
          <option value="paywalls">Open access science vs paywalls after free work</option>
          <option value="spam">Constructive review vs automated invitations</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <label for="noText">NO text (left)</label>
        <input id="noText" type="text" value="Peer review for paywalls and APCs" />
      </div>
      <div class="col">
        <label for="yesText">YES text (right)</label>
        <input id="yesText" type="text" value="Peer review for diamond open access" />
      </div>
    </div>

    <div class="row">
      <button id="downloadBtn">Download PNG</button>
      <button id="copyBtn">Copy image</button>
      <button id="copyLinkBtn">Copy link</button>
      <button id="clearAllBtn">Clear all</button>
    </div>

    <!-- Live preview (fixed 1800x360; CSS scales it to fit) -->
    <canvas id="c" width="1800" height="360"></canvas>

    <div class="links">
      <a href="https://www.linkedin.com/in/eelkedevries" target="_blank" rel="noopener noreferrer">LinkedIn</a>
      &nbsp;|&nbsp;
      <a href="https://github.com/eelkedevries/" target="_blank" rel="noopener noreferrer">GitHub</a>
    </div>
  </div>

  <script>
    // ---------- DOM ----------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const presetSelect = document.getElementById("presetSelect");
    const noInput = document.getElementById("noText");
    const yesInput = document.getElementById("yesText");

    const downloadBtn = document.getElementById("downloadBtn");
    const copyBtn = document.getElementById("copyBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    // Fixed output size (per your requirement)
    const FIXED_W = 1800;
    const FIXED_H = 360;

    // ---------- Defaults ----------
    const DEFAULTS = {
      yes: "Peer review for diamond open access",
      no: "Peer review for paywalls and APCs"
    };

    const PRESETS = {
      diamond: {
        yes: "Peer review for diamond open access",
        no: "Peer review for paywalls and APCs"
      },
      nonprofit: {
        yes: "Peer review for non-profit publishing",
        no: "Peer review for publisher profit"
      },
      paywalls: {
        yes: "Peer review for open access science",
        no: "Peer review for paywalls after free work"
      },
      spam: {
        yes: "Constructive peer review",
        no: "Automated reviewer invitations"
      }
    };

    const COLORS = {
      bg: "#000000",
      border: "#FFFFFF",
      no: "#E53935",
      yes: "#00B050",
      text: "#FFFFFF"
    };

    // ---------- URL params (yes/no only) ----------
    // Supported:
    // ?yes=...&no=...
    function getParams() {
      const p = new URLSearchParams(window.location.search);
      return { yes: p.get("yes"), no: p.get("no") };
    }

    function applyParams() {
      const p = getParams();
      if (p.yes !== null) yesInput.value = p.yes;
      if (p.no !== null) noInput.value = p.no;
    }

    function updateURL() {
      const p = new URLSearchParams();
      p.set("yes", yesInput.value);
      p.set("no", noInput.value);
      const newUrl = `${window.location.pathname}?${p.toString()}`;
      window.history.replaceState({}, "", newUrl);
    }

    async function copyLink() {
      try {
        await navigator.clipboard.writeText(window.location.href);
        alert("Link copied to clipboard.");
      } catch (e) {
        alert("Could not copy link. You can copy it manually from the address bar.");
      }
    }

    // ---------- Text helpers ----------
    function wrapText(targetCtx, text, maxWidth, fontSize, maxLines) {
      targetCtx.font = `bold ${fontSize}px Arial`;
      const words = (text || "").trim().split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";

      for (const w of words) {
        const test = line ? `${line} ${w}` : w;
        if (targetCtx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
      return lines.slice(0, maxLines);
    }

    // Fit a single shared font size for both "YES" and "NO" within the label blocks
    function fitLabelFontSize(targetCtx, labelBlockW, innerH) {
      const maxW = labelBlockW * 0.86; // leave comfortable side padding
      const maxH = innerH * 0.80;      // leave top/bottom padding
      let size = Math.floor(innerH * 0.62); // starting point

      while (size > 20) {
        targetCtx.font = `bold ${size}px Arial`;
        const yesW = targetCtx.measureText("YES").width;
        const noW  = targetCtx.measureText("NO").width;

        if (yesW <= maxW && noW <= maxW && size <= maxH) {
          return size;
        }
        size -= 2;
      }
      return 20;
    }

    // ---------- Drawing ----------
    function drawSticker(targetCtx, W, H) {
      // Proportions tuned to match your reference and ensure YES fits
      const border = Math.max(10, Math.round(W * 0.006));
      const pad = Math.round(W * 0.015);
      const sepW = Math.max(10, Math.round(W * 0.006));

      // Equal-sized red/green blocks (requirement)
      const labelBlockW = Math.round(W * 0.16); // slightly wider so YES always fits
      const innerH = H - 2 * border;

      const totalInnerW = W - 2 * border;
      const textAreaW = (totalInnerW - 2 * labelBlockW - sepW) / 2;

      const xNoBlock = border;
      const xNoText = border + labelBlockW;
      const xSep = xNoText + textAreaW;
      const xYesText = xSep + sepW;
      const xYesBlock = xYesText + textAreaW;

      // Background
      targetCtx.clearRect(0, 0, W, H);
      targetCtx.fillStyle = COLORS.bg;
      targetCtx.fillRect(0, 0, W, H);

      // Outer border
      targetCtx.strokeStyle = COLORS.border;
      targetCtx.lineWidth = border;
      targetCtx.strokeRect(border / 2, border / 2, W - border, H - border);

      // Separator line
      targetCtx.fillStyle = COLORS.border;
      targetCtx.fillRect(xSep, border, sepW, innerH);

      // Blocks (equal widths)
      targetCtx.fillStyle = COLORS.no;
      targetCtx.fillRect(xNoBlock, border, labelBlockW, innerH);

      targetCtx.fillStyle = COLORS.yes;
      targetCtx.fillRect(xYesBlock, border, labelBlockW, innerH);

      // Big fixed labels (YES/NO must match font size)
      targetCtx.fillStyle = COLORS.text;
      targetCtx.textAlign = "center";
      targetCtx.textBaseline = "middle";

      const labelFontSize = fitLabelFontSize(targetCtx, labelBlockW, innerH);
      targetCtx.font = `bold ${labelFontSize}px Arial`;
      targetCtx.fillText("NO", xNoBlock + labelBlockW / 2, H / 2);
      targetCtx.fillText("YES", xYesBlock + labelBlockW / 2, H / 2);

      // Text areas
      targetCtx.fillStyle = COLORS.text;
      targetCtx.textAlign = "left";
      targetCtx.textBaseline = "top";

      const startSize = Math.round(H * 0.18);
      const minSize = Math.max(18, Math.round(H * 0.10));
      const maxLines = 3;
      const maxW = textAreaW - 2 * pad;

      function fitTextLocal(text) {
        let size = startSize;
        while (size >= minSize) {
          targetCtx.font = `bold ${size}px Arial`;
          const lines = wrapText(targetCtx, text, maxW, size, maxLines);

          // Verify each line fits
          let ok = true;
          for (const ln of lines) {
            if (targetCtx.measureText(ln).width > maxW) { ok = false; break; }
          }
          if (ok) return { size, lines };
          size -= 2;
        }
        return { size: minSize, lines: wrapText(targetCtx, text, maxW, minSize, maxLines) };
      }

      const noFit = fitTextLocal(noInput.value);
      targetCtx.font = `bold ${noFit.size}px Arial`;
      let y = border + Math.round(H * 0.18);
      for (const line of noFit.lines) {
        targetCtx.fillText(line, xNoText + pad, y);
        y += noFit.size + Math.round(H * 0.04);
      }

      const yesFit = fitTextLocal(yesInput.value);
      targetCtx.font = `bold ${yesFit.size}px Arial`;
      y = border + Math.round(H * 0.18);
      for (const line of yesFit.lines) {
        targetCtx.fillText(line, xYesText + pad, y);
        y += yesFit.size + Math.round(H * 0.04);
      }
    }

    function renderPreview() {
      // Ensure fixed size (preview + export match exactly)
      canvas.width = FIXED_W;
      canvas.height = FIXED_H;
      drawSticker(ctx, canvas.width, canvas.height);
    }

    // ---------- Export / clipboard ----------
    function downloadPNG() {
      const a = document.createElement("a");
      a.download = "yes-no-sticker.png";
      a.href = canvas.toDataURL("image/png");
      a.click();
    }

    async function copyImage() {
      try {
        if (!navigator.clipboard || !window.ClipboardItem) {
          alert("Clipboard image copy is not supported in this browser.");
          return;
        }
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
        if (!blob) {
          alert("Could not create image blob.");
          return;
        }
        await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
        alert("Image copied to clipboard.");
      } catch (e) {
        console.error(e);
        alert("Copy failed.");
      }
    }

    // ---------- Presets ----------
    function applyPreset(key) {
      if (!key || !PRESETS[key]) return;
      yesInput.value = PRESETS[key].yes;
      noInput.value = PRESETS[key].no;
    }

    // ---------- Clear all ----------
    function clearAll() {
      presetSelect.value = "";
      yesInput.value = DEFAULTS.yes;
      noInput.value = DEFAULTS.no;
      updateURL();
      renderPreview();
    }

    // ---------- Live updates ----------
    function onAnyChange() {
      updateURL();
      renderPreview();
    }

    // ---------- Init ----------
    applyParams();
    updateURL();
    renderPreview();

    // ---------- Events ----------
    yesInput.addEventListener("input", onAnyChange);
    noInput.addEventListener("input", onAnyChange);

    presetSelect.addEventListener("change", () => {
      applyPreset(presetSelect.value);
      onAnyChange();
    });

    downloadBtn.addEventListener("click", downloadPNG);
    copyBtn.addEventListener("click", copyImage);
    copyLinkBtn.addEventListener("click", copyLink);
    clearAllBtn.addEventListener("click", clearAll);

    window.addEventListener("resize", () => renderPreview());
  </script>
</body>
</html>
